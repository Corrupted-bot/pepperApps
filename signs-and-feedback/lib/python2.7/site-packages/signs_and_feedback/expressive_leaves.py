from expressive_bit_class import ExpressiveBit
from utils.utils import check_assign, get_requirements
import qi


class ExpressiveLeaf(ExpressiveBit):

    requirements = ["ALBehaviorManager"]

    def __init__(self, session, bit_dict, logger, bits_lib):
        super(ExpressiveLeaf, self).__init__(session, bit_dict, logger,
                                             bits_lib)
        self.is_continuous = "type" in bit_dict \
            and bit_dict["type"] == "continuous"
        self.logger.info("Continuous type for {name}: {is_continuous}"
                         .format(name=self.name,
                                 is_continuous=self.is_continuous))

    def get_is_continuous(self):
        return self.is_continuous


class ExpressiveLeafBehavior(ExpressiveLeaf):

    bit_type = "behavior"

    def __init__(self, session, bit_dict, logger, bits_lib):
        super(ExpressiveLeafBehavior, self).__init__(session, bit_dict, logger,
                                                     bits_lib)
        self.behavior_manager = self.session.service("ALBehaviorManager")
        check_assign(self, "behavior", bit_dict)
        self.check_is_installed()
        self.preload()

    def switch_exec(self, switcher):
        try:
            self.logger.info(("start" if switcher else "stop") + " behavior: " +
                             self.behavior)
            self.behavior_manager.stopBehavior(self.behavior)
            if switcher:
                self.logger.info("    > run behavior: " + self.behavior)
                behavior_future = qi.async(self.behavior_manager.runBehavior, self.behavior)
                # Note: some behavior just don't return (frequent in animation library)
                # so we have to use a timeout to cut them
                self.wait_with_timeout(behavior_future)
                self.logger.info("run runBehavior")
        except RuntimeError, error:
            self.logger.error(
                "Error playing pose: " + self.behavior + ". Got: " + str(error))

    def get_switch_event_value(self, switcher):
        value_dict = super(ExpressiveLeaf, self).get_switch_event_value(switcher)
        value_dict["behavior"] = self.behavior
        return value_dict

    def check_is_installed(self):
        self.logger.assert_warning(
            self.behavior_manager.isBehaviorInstalled(self.behavior),
            "In ExpressiveBit \"{name}\", behavior \"{behavior}\" isn't installed"
            .format(name=self.name, behavior=self.behavior))

    def preload(self):
        self.behavior_manager.preloadBehavior(self.behavior)


class ExpressiveLeafLibCall(ExpressiveLeaf):

    bit_type = "lib_call"

    def __init__(self, session, bit_dict, logger, bits_lib):
        super(ExpressiveLeafLibCall, self).__init__(session, bit_dict, logger,
                                                    bits_lib)
        self.bits_library_dict = bits_lib.get_bits_library_dict()
        check_assign(self, "lib_call", bit_dict)
        self.logger.assert_warning(
            self.lib_call in self.bits_library_dict,
            self.lib_call + " isn't installed")
        self.method = self.bits_library_dict[self.lib_call]

    def switch_exec(self, switcher):
        if switcher:
            self.method()
        else:
            # stop SF with API call is not taken care of for the moment
            pass

    def get_switch_event_value(self, switcher):
        value_dict = super(ExpressiveLeaf, self).get_switch_event_value(switcher)
        value_dict["lib_call"] = self.lib_call
        return value_dict
