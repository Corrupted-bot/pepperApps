from utils.utils import Timer
from utils.events_handler import EventsHandler
import qi


@qi.singleThreaded()
class DialogEventsWrapper(object):
    """Asr/tts event, retrigger
    """
    event_asr_status = "ALSpeechRecognition/Status"
    event_tts_started = "ALTextToSpeech/TextStarted"
    event_dialog_switch = "Dialog/IsStarted"
    event_notifications_say = "ALNotificationReader/SayingNotification"
    event_start_notification_blink = "ALExpressiveness/StartNotificationBlink"
    event_stop_notification_blink = "ALExpressiveness/StopNotificationBlink"

    input_events = [
        event_asr_status, event_tts_started, event_dialog_switch,
        event_notifications_say, event_start_notification_blink,
        event_stop_notification_blink,
    ]

    event_prefix = "ALSignsAndFeedback"
    event_listening = event_prefix + "/Listening"
    event_hearing = event_prefix + "/Hearing"
    event_speaking = event_prefix + "/Speaking"
    event_processing = event_prefix + "/Processing"
    event_relaunching = event_prefix + "/Relaunching"
    event_asr_stop = event_prefix + "/ASRStop"
    event_dialog_start = event_prefix + "/DialogStart"
    event_dialog_stop = event_prefix + "/DialogStop"
    event_start_notification_blink_prefix = event_prefix + \
        "/StartNotificationBlink/"
    event_stop_notification_blink_prefix = event_prefix + \
        "/StopNotificationBlink/"

    event_initialization = event_prefix + "/Initialization"

    events = [
        event_listening, event_hearing, event_speaking, event_processing,
        event_asr_stop, event_relaunching,
        event_dialog_start, event_dialog_stop,
        event_initialization,
    ]
    requirements = ["ALMemory"]

    def __init__(self, session, logger):
        super(DialogEventsWrapper, self).__init__()
        self.logger = logger
        self.session = session
        self.got_process = False
        self.has_listened = None
        self.is_listening = False
        self.speech_detected = False
        self.is_saying_notification = False
        self.last_raised_event = None
        self.events_handler = EventsHandler(session)

        callback_dict = {
            self.event_asr_status: self.on_asr_status,
            self.event_tts_started: self.on_tts_started,
            self.event_dialog_switch: self.on_dialog_switch,
            self.event_notifications_say: self.on_notification_say,
            self.event_start_notification_blink: self.on_start_notification_blink,
            self.event_stop_notification_blink: self.on_stop_notification_blink,
        }
        for event_name, callback in callback_dict.iteritems():
            self.events_handler.connect_callback(
                event_name, callback)
        self.dialog_started = False
        self.memory = session.service("ALMemory")
        self.raise_event(self.event_initialization)

    def reset(self):
        # maybe not useful?
        self.speech_detected = False
        self.has_listened = None

    def on_asr_status(self, parameter):
        if not self.is_engaged_dialog():
            self.logger.info("Got event ALSpeechRecognition/Status " +
                             "in unengaged dialog")
            self.is_listening = False
            return
        self.logger.info("DialogEventsWrapper: Status:" + parameter)
        if parameter == "ListenOn":
            if self.last_raised_event != self.event_listening and not self.is_saying_notification:
                self.raise_event(self.event_listening)
                self.got_process = False
            self.is_listening = True
        else:
            self.is_listening = False
            if parameter == "SpeechDetected":
                self.speech_detected = True
                self.raise_event(self.event_hearing)
            elif parameter == "EndOfProcess" and self.speech_detected \
                and not self.got_process:
                self.raise_event(self.event_processing)
                self.got_process = True
            elif parameter == "Stop":
                self.raise_event(self.event_asr_stop)
                self.reset()

    def on_tts_started(self, switcher):
        if self.is_in_sleep_mode():
            return
        self.logger.info("DialogEventsWrapper: on_tts_started:", switcher)
        if switcher:
            if not self.speech_detected and \
                    self.is_a_while_since_listened():
                self.raise_event(self.event_relaunching)
                self.logger.info("DialogEventsWrapper: Relaunching:" +
                    str(self.speech_detected) + "/" +
                    str(self.is_a_while_since_listened()))
            else:
                self.logger.info("DialogEventsWrapper: Speaking")
                self.raise_event(self.event_speaking)
            self.speech_detected = False

    def on_dialog_switch(self, value):
        if not self.is_engaged_dialog():
            return
        if value == "1" :
            self.try_switch_raise_dialog(True)
        elif value == "0":
            self.try_switch_raise_dialog(False)

    def try_switch_raise_dialog(self, switcher):
        if self.dialog_started == switcher:
            return
        if not self.is_in_sleep_mode():
            self.raise_event(self.event_dialog_start if switcher
                             else self.event_dialog_stop)
        self.dialog_started = switcher

    def on_notification_say(self, switcher):
        self.is_saying_notification = switcher
        if switcher:
            self.logger.info("DialogEventsWrapper: Saying notification")
            self.raise_event(self.event_speaking)
        else:
            if self.is_listening:
                self.raise_event(self.event_listening)

    def raise_event(self, name_event):
        self.logger.info("DialogEventsWrapper: triggering event:" + name_event)
        self.events_handler.raise_event(name_event, None)
        self.last_raised_event = name_event

    def is_a_while_since_listened(self):
        time_listened = self.has_listened
        if time_listened is None:
            return False
        else:
            elapsed_time = time_listened.get_elapsed_time()
            return elapsed_time > 1.0

    def is_engaged_dialog(self):
        # NB: we don't get the service in __init__ because we would have to add
        # ALSpeechRecognition to the requirements, which would create a
        # circular dependency, as ALSpeechRecognition calls
        # SignsAndFeedback.triggerBit
        try:
            self.speech_recognition = \
                self.session.service("ALSpeechRecognition")
            return self.speech_recognition._beamformerEnabled()
        except RuntimeError, error:
            # this shouldn't happen
            # (SpeechReco event, but no SpeechReco service)
            self.logger.warning("Got an ALSpeechRecognition event, but "
                                "ALSpeechRecognition service is not available")
            return False

    def is_in_sleep_mode(self):
        data_name = "AutonomousLife/Asleep"
        try:
            return self.memory.getData(data_name) == 1
        except RuntimeError, error:
            self.logger.warning("Couldn't get data " + data_name + ": " +
                                str(error))
            return False

    def on_start_notification_blink(self, value):
        self.raise_event(self.event_start_notification_blink_prefix + value)

    def on_stop_notification_blink(self, value):
        event_name = self.event_stop_notification_blink_prefix + \
            ("Listening" if self.is_listening else "NotListening")
        self.logger.info("on_stop_notification_blink: " + event_name)
        self.raise_event(event_name)
