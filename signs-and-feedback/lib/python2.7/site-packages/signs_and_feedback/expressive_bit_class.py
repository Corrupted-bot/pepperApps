#-*- coding: utf-8 -*-
from utils.utils import get_value_or_none, assert_warning_expr, \
    check_assign, RandIndex, get_requirements
from utils.events_handler import EventsHandler
import random
import qi


class ExpressiveBit(object):
    """ ExpressiveBits have a tree structure:
        A node can be:
            -either an internal node (serialize, random, simultaneous),
            -or a leaf.
        When switched, a node will switch all its children in a specific way,
        until a leaf is reached (then the behavior/lib_call is simply run)
    """

    bit_type = None  # this should be in the bit dictionary, and will determine
        # the class to use for the bit
    event_switched = "ALSignsAndFeedback/Switched"
    timeout_switch_secs = 5.0  # it should be longer than the longest S&F

    def __init__(self, session, bit_dict, logger, bits_lib):
        self.logger = logger
        self.session = session
        check_assign(self, "name", bit_dict, "expressive_bit")
        self.events_handler = EventsHandler(self.session)

    def switch(self, switcher):
        event_value =  self.get_switch_event_value(switcher)
        self.logger.info("Running bit: {name}/{event_value}"
                         .format(name=self.name, event_value=str(event_value)))
        self.events_handler.raise_event(self.event_switched, event_value)
        try:
            self.switch_exec(switcher)
        except RuntimeError, error:
            self.logger.error("Error running bit: " + str(self.name))
            raise error
        self.logger.info("Finished running bit: {name}/{event_value}"
                         .format(name=self.name, event_value=str(event_value)))

    def switch_exec(self, switcher):
        return NotImplemented

    # todo: get_children_bits is a bad name, as it doesn't return children bits
    def get_children_bits(self, bits_names_dict):
        # we want it for ExpressiveLeaf as well, so that it's generic at
        # high level... so it's not a NotImplemented
        pass

    def get_switch_event_value(self, switcher):
        return {
            "switcher": switcher,
            "name": self.name,
            "bit_type": self.bit_type
        }

    @classmethod
    def wait_with_timeout(cls, future):
        timeout_switch_millisecs = int(cls.timeout_switch_secs * 1000)
        future.wait(timeout_switch_millisecs)

