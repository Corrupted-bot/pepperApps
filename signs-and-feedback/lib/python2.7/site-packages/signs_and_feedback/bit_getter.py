from expressive_leaves import ExpressiveLeafBehavior, ExpressiveLeafLibCall
from expressive_nodes import ExpressiveSerializeNode, ExpressiveRandomNode, \
    ExpressiveSimultaneousNode
from hardcoded_sf_library import BitsLibrary
from utils.utils import get_requirements


bits_classes = [  # all not-abstract classes
    ExpressiveLeafBehavior,
    ExpressiveLeafLibCall,
    ExpressiveSerializeNode,
    ExpressiveRandomNode,
    ExpressiveSimultaneousNode,
]

bits_requirements = get_requirements(bits_classes + [BitsLibrary])

def get_bit_from_dict(session, bit_dict, logger, bits_lib):
    """ get a bit object from a dict extracted from yaml, eg:
        - expressive_bit: ShoulderOff
          lib_call: setShoulderOff
    """
    bit_types_dict = {BitClass.bit_type: BitClass for BitClass in bits_classes}
    logger.assert_warning("expressive_bit" in bit_dict,
                          "Error: no expressive_bit field in get_bit_from_dict")
    name = bit_dict["expressive_bit"]
    # check there is exactly one bit type in bit_dict
    logger.assert_warning(
        len([bit_type for bit_type in bit_types_dict
             if bit_type in bit_dict]) == 1,
        "Bit type problem for bit: " + name)
    # get node type
    ExpressiveBitClass = None
    for alleged_type, BitClass in bit_types_dict.iteritems():
        if alleged_type in bit_dict:
            ExpressiveBitClass = BitClass
            break
    logger.info("Building bit {name_bit} (type: {class_bit})"
                .format(name_bit=name, class_bit=str(ExpressiveBitClass)))
    return ExpressiveBitClass(session, bit_dict, logger, bits_lib)
