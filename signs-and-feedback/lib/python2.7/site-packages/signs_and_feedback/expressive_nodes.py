from expressive_bit_class import ExpressiveBit
from utils.utils import check_assign, RandIndex
import qi


class ExpressiveInternalNode(ExpressiveBit):
    """ Abstract class for internal nodes
    """

    def __init__(self, session, bit_dict, logger, bits_lib):
        super(ExpressiveInternalNode, self).__init__(session, bit_dict, logger,
                                                     bits_lib)
        self.children_bits = []
        check_assign(self, "children_bits_names", bit_dict, self.bit_type)

    @classmethod
    def make_from_arguments(cls, name, children_bits_names, session, logger):
        """ make a ExpressiveInternalNode without a bit_dict
        """
        artificial_bit_dict = {
            "expressive_bit": name,
            cls.bit_type: children_bits_names,
        }
        return cls(session, artificial_bit_dict, logger, {})

    def get_children_bits(self, bits_names_dict):
        # this must be run after all bits are initialized
        for children_bit_name in self.children_bits_names:
            self.logger.assert_warning(
                children_bit_name in bits_names_dict,
                "ExpressiveBit \"" + children_bit_name + "\" wasn't found")
        self.children_bits = \
            [bits_names_dict[children_bit_name]
             for children_bit_name in self.children_bits_names]

    def get_is_continuous(self):
        """ set/check if continous, may have to check the children too
        """
        return any(child_bit.get_is_continuous()
                   for child_bit in self.children_bits)


class ExpressiveRandomNode(ExpressiveInternalNode):

    bit_type = "random"

    def __init__(self, session, bit_dict, logger, bits_lib):
        super(ExpressiveRandomNode, self).__init__(session, bit_dict, logger,
                                                   bits_lib)
        self.random_bit_index = None
        self.random_bit = None

    def switch_exec(self, switcher):
        # todo: the "specific bit stop" should be generic!
        if self.random_bit_index is None:
            self.random_bit_index = RandIndex(self.children_bits)
        if switcher:
            self.random_bit = self.random_bit_index.get_next_element()
        else:
            if self.random_bit is None:
                # allow stop when not started
                return
        self.random_bit.switch(switcher)
        if not switcher:
            self.random_bit = None


class ExpressiveSerializeNode(ExpressiveInternalNode):

    bit_type = "serialize"

    def switch_exec(self, switcher):
        for children_bit in self.children_bits:
            children_bit.switch(switcher)


class ExpressiveSimultaneousNode(ExpressiveInternalNode):

    bit_type = "simultaneous"

    def switch_exec(self, switcher):
        if switcher:
            self.logger.verbose("Simultaneous Switch: " +
                                str([child_bit.name
                                     for child_bit in self.children_bits]))
            bit_futures = []
            for child_bit in self.children_bits:
                self.logger.verbose("  trigger child: " + child_bit.name +
                                    " (" + str(type(child_bit)) + ")")
                bit_future = qi.async(child_bit.switch, switcher)
                bit_futures.append(bit_future)
            for bit_future in bit_futures:
                self.wait_with_timeout(bit_future)
