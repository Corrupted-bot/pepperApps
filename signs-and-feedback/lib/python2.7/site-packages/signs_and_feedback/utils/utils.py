import random
import thread
import math
import qi
import time
import datetime


class RandIndex():
    """ Give a random item of a list, don't give the same item twice
    """

    def __init__(self, list_elements):
        self.list_elements = list_elements
        self.last_index = None

    def get_next_element(self):
        if len(self.list_elements) == 1:
            return self.list_elements[0]
        else:
            rand_index = None
            while rand_index is None or rand_index == self.last_index:
                rand_index = random.randint(0, len(self.list_elements) - 1)
            self.last_index = rand_index
            return self.list_elements[self.last_index]


def get_requirements(class_list, additional_requirements=[]):
    """ merge requirements from a class list
    """
    seen = set()
    seen_add = seen.add
    requirements_duplicates = []
    for class_item in class_list:
        if hasattr(class_item, "requirements"):
            requirements_duplicates += class_item.requirements
    requirements_duplicates += additional_requirements
    return [requirement for requirement in requirements_duplicates
            if not (requirement in seen or seen_add(requirement))]


def wait_for_services(session, requirements, timeout=100, logger=None):
    """ wait for services listed in requirements, with a timeout
        (this is just a small qi.waitForService wrapper)
          - requirements: list of service names
    """
    for requirement in requirements:
        if logger is not None:
            logger.info("Waiting for requirement: " + requirement)
        future_requirement = session.waitForService(requirement)
        if future_requirement is not None:
            state = future_requirement.wait(timeout)
            if state != qi.FutureState.FinishedWithValue:
                raise RuntimeError("Timeout when waiting for service: " +
                                   requirement)


def get_session(opts):
    session = qi.Session()
    session.connect("tcp://" + opts.ip + ":" + str(opts.port))
    return session


class Timer(object):

    def __init__(self):
        self.set_time_origin_to_now()

    def set_time_origin_to_now(self):
        self.time_origin = datetime.datetime.now()

    def get_elapsed_time(self):
        delta_time = datetime.datetime.now() - self.time_origin
        return delta_time.seconds + delta_time.microseconds / 1e6

    @staticmethod
    def elapsed_time(void_func, do_print, name_func):

        def print_time_func():
            timer = Timer()
            void_func()
            print "elapsed_time for", name_func + ":", timer.get_elapsed_time()

        return print_time_func


class RandIndex():
    """ Give a random item of a list, don't give the same item twice
    """

    def __init__(self, list_elements):
        self.list_elements = list_elements
        self.last_index = None

    def get_next_element(self):
        if len(self.list_elements) == 1:
            return self.list_elements[0]
        else:
            rand_index = None
            while rand_index is None or rand_index == self.last_index:
                rand_index = random.randint(0, len(self.list_elements) - 1)
            self.last_index = rand_index
            return self.list_elements[self.last_index]


def get_value_or_none(key, dictionary):
    return dictionary[key] if key in dictionary else None


def assert_warning_expr(expr_object, assertion, error_message):
    name_obj = ": \"" + expr_object.name + "\"" if hasattr(expr_object, "name") \
        else ""
    error_message += " for ExpressiveObject" + name_obj
    expr_object.logger.assert_warning(assertion, error_message)


def check_assign(expr_object, attr_name, input_dict, key_name=None):
    """ check dict for some keys, and assign them to the current object if
        they are present
    """
    if key_name is None:
        key_name = attr_name
    assert_warning_expr(expr_object, key_name in input_dict,
                        "No " + key_name + " specified")
    setattr(expr_object, attr_name, input_dict[key_name])