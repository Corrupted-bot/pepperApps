#-*- coding: utf-8 -*-
import utils.utils
from dialog_events_wrapper import DialogEventsWrapper
from awareness_events_wrapper import AwarenessEventsWrapper
from expressive_configuration import ExpressiveConfiguration
import qi
import os


@qi.multiThreaded()
class SignsAndFeedback(object):
    """ Trigger signs and feedback
    """

    service_name = "ALSignsAndFeedback"
    tag_config = "SignsAndFeedbackConfig"
    name_custom_config_file =  "config_signs_and_feedback.yaml"
    path_default_config = "signs_and_feedback/config_old_signs_and_feedback.yaml"
    path_robot = \
        "/data/home/nao/.local/share/PackageManager/apps/signs-and-feedback"
    requirements = utils.utils.get_requirements(
        [ExpressiveConfiguration, DialogEventsWrapper, AwarenessEventsWrapper])

    def __init__(self, session):
        super(SignsAndFeedback, self).__init__()
        self.session = session
        self.logger = qi.Logger(self.service_name)
        try:
            self.logger.info("Getting requirements: " + str(self.requirements))
            utils.utils.wait_for_services(session, self.requirements, 10, self.logger)
            self.logger.info("All requirements were found!")
        except Exception, error:
            self.logger.error("Couldn't get service requirement: " + str(error))
            raise error
        self.dialog_events_wrapper = DialogEventsWrapper(session, self.logger)
        self.awareness_events_wrapper = AwarenessEventsWrapper(session,
                                                               self.logger)
        self.configuration = None
        path_prototype_config = self.get_app_config_path()
        if path_prototype_config is not None:
            self.set_tagged_app_config(path_prototype_config)
        else:
            self.set_default_configuration()

    @qi.nobind
    def set_config_with_path(self, path_folder):
        full_path_config = os.path.join(path_folder, self.path_default_config)
        self.set_configuration(full_path_config)

    @qi.nobind
    def set_default_configuration(self):
        try:
            self.set_config_with_path(self.path_robot)
        except IOError, error_robot:
            # if we failed finding a config file with the robot path,
            # we might be running the service remotely, thus try using
            # the local default config file
            try:
                path_local = os.path.join(
                    os.path.dirname(os.path.abspath(__file__)), os.pardir)
                self.set_config_with_path(path_local)
            except IOError, error_local:
                raise error_robot


    @qi.bind(methodName="triggerBit", paramsType=(qi.String,),
             returnType=qi.Void)
    def trigger_bit(self, object_name):
        """ Trigger one of the expressive_bits specified in the configuration
            the argument can be a bit name or a recipe name. This is a blocking
            call.
        """
        self.logger.info("Manually triggering the bit: " + object_name)
        self.configuration.trigger_bit(object_name)


    @qi.bind(methodName="_setConfiguration", paramsType=(qi.String,),
             returnType=qi.Void)
    def set_configuration(self, path_yaml):
        """ Set the path for the yaml configuration file and set the
            signs and feedback behaviors and triggers accordingly
        """
        if self.configuration is not None:
            self.configuration.disconnect_callbacks()
        self.configuration = ExpressiveConfiguration(self.session, path_yaml)

    @qi.bind(methodName="_resetConfiguration", paramsType=(),
             returnType=qi.Void)
    def reset_configuration(self):
        """ Reset the configuration using default configuration file
        """
        self.set_default_configuration()

    @qi.bind(methodName="_getBitsNames", paramsType=(),
             returnType=qi.List(qi.String))
    def get_bits_names(self):
        """ Get all ExpressiveBits' names
        """
        return self.configuration.get_bits().keys()

    @qi.bind(methodName="_getStates", paramsType=(),
             returnType=qi.List(qi.String))
    def get_states(self):
        """ Get the last triggered Recipes
        """
        # todo: we should have state machine implementation for this to really
        # make sense, but for now we just take the latest recipes
        return self.configuration.get_states()

    @qi.nobind
    def get_app_config_path(self):
        """ It is possible to deliver a configuration via a tagged
            package/application, here we find the path of the path for the
            package configuration file
        """
        package_manager = self.session.service("PackageManager")
        package_info_list = package_manager.packages()
        self.logger.info("Searching {nb_packages} packages for tag {tag}"
                         .format(nb_packages=len(package_info_list),
                                 tag=self.tag_config))
        forbidden_uuid = [".lastUploadedChoregrapheBehavior", "animations"]
        package_info_list = [package_info for package_info in package_info_list
                             if package_info["uuid"] not in forbidden_uuid]
        for package_info in package_info_list:
            for behavior in package_info["behaviors"]:
                for langage_tags in behavior["langToTags"].values():
                    if self.tag_config in langage_tags:
                        path_config_behavior = package_info["uuid"] + "/" + \
                            behavior["path"]
                        self.logger.info("Found behavior: " +
                                         str(path_config_behavior))
                        return path_config_behavior
        self.logger.info("No tagged application found, will use default "
                         "configuration")
        return None

    @qi.nobind
    def set_tagged_app_config(self, path_config):
        self.logger.info(
            "Replacing default configuration by custom configuration " +
            "from: " + path_config)
        try:
            # todo:
            # - find full_path_config dynamically
            # - allow other names for config file
            full_path_config = "/home/nao/.local/share/PackageManager/apps/" + \
                path_config + "/" + self.name_custom_config_file
            self.set_configuration(full_path_config)
        except IOError, error:
            self.logger.error("Failed to load custom configuration, will load "
                              "default configuration (%s)" % str(error))
            self.set_default_configuration()
