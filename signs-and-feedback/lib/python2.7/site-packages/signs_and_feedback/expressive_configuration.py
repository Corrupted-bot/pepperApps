from bit_getter import get_bit_from_dict, bits_requirements
from expressive_recipe import ExpressiveRecipe
from utils.events_handler import EventsHandler
from utils.utils import check_assign, get_requirements
from hardcoded_sf_library import BitsLibrary
import yaml
import qi


class ConfigLogger(qi.Logger):

    def __init__(self, path_yaml):
        qi.Logger.__init__(self, ExpressiveConfiguration.service_name)
        self.path_yaml = path_yaml

    def assert_warning(self, assertion, error_message):
        error_message += " in configuration file: " + str(self.path_yaml)
        if not assertion:
            self.error(error_message)
            raise RuntimeError(error_message)


class ExpressiveConfiguration(object):
    """Handle a configuration, with its ExpressiveBits and ExpressiveRecipes
    """

    service_name = "ExpressiveConfiguration"
    requirements = bits_requirements

    def __init__(self, session, path_yaml):
        super(ExpressiveConfiguration, self).__init__()
        self.path_yaml = path_yaml
        self.logger = ConfigLogger(path_yaml)
        self.events_handler = EventsHandler(session)
        self.session = session
        try:
            self.logger.info("Getting configuration file: " + path_yaml)
            self.current_recipes = []
            yaml_list = self.get_yaml_infos(path_yaml)
            self.make_bits_recipes(yaml_list)
            self.connect_expressive_callbacks()
        except RuntimeError, error:
            self.logger.error("Error in _setConfiguration: " + str(error))
            raise error

    def get_yaml_infos(self, path_yaml):
        """ yaml_list = [yaml_dict, ...]
                where yaml_dict is a recipe dict or a bit dict
            recipes_list = [ExpressiveRecipeObject1, ...]
            bits_dict = {theBitName1: ExpressiveBitObject1, ...}
        """
        self.path_yaml = path_yaml
        try:
            stream = file(path_yaml, 'r')
            yaml_list = yaml.load(stream)
            return yaml_list
        except RuntimeError, error:
            self.logger.error("Error when loading configuration file: " +
                              path_yaml)
            raise error

    def make_bits_recipes(self, yaml_list):
        # make the hardcoded bits library (it should be defined only once!)
        bits_lib = BitsLibrary(self.session, self.logger)
        bits_list = [get_bit_from_dict(self.session, yaml_dict, self.logger,
                                       bits_lib)
                     for yaml_dict in yaml_list
                     if "expressive_bit" in yaml_dict]
        self.bits_dict = {bit.name: bit for bit in bits_list}
        for bit in bits_list:
            bit.get_children_bits(self.bits_dict)

        self.recipes_list = [ExpressiveRecipe(yaml_dict, self.bits_dict,
                                              self.session, self.logger)
                             for yaml_dict in yaml_list
                             if "expressive_recipe" in yaml_dict]

        # check file consistency
        for expressive_recipe in self.recipes_list:
            expressive_recipe.check_consistency()

    def connect_expressive_callbacks(self):
        self.events_handler.disconnect_all_callbacks()
        for event_name, switch_dict in self.make_events_dict().iteritems():
            self.make_connect_callback(event_name, switch_dict)

    def make_events_dict(self):
        # events_dict:
        # {event_name_1:{"start":[bit_1, ...], "stop":[bit_2, ...]},
        #  event_name_2: {...}, ...}
        events_dict = {}

        for expressive_recipe in self.recipes_list:
            for switcher in ["stop", "start"]:
                event_names = expressive_recipe.stop if switcher == "stop" \
                    else [expressive_recipe.trigger]
                for event_name in event_names:
                    if event_name is not None:
                        if event_name not in events_dict:
                            events_dict[event_name] = {
                                "start":[],
                                "stop":[],
                                "recipes":[],
                                # todo: the recipe is not very coherent here
                            }
                    events_dict[event_name][switcher].\
                        append(expressive_recipe.bit)
                    if switcher == "start":
                        events_dict[event_name]["recipes"].\
                            append(expressive_recipe)
        self.logger.info("Made events dict: " + str(
            {event_name: {tag: [bit.name for bit in bits]
                          for tag, bits in tag_dict.iteritems()}
             for event_name, tag_dict in events_dict.iteritems()}))
        return events_dict

    @staticmethod
    def bits_to_str(bits_list):
        return str([bit.name for bit in bits_list])

    def make_connect_callback(self, event_name, switch_dict):

        def callback_switch_expressive_recipes(value):
            """ for the event, stop all the old bits, then start the new ones
            """
            self.current_recipes = switch_dict["recipes"]
            self.logger.info("Running recipe {name}: "
                             "starting {events_start}/stopping {events_stop}"
                             .format(name=event_name,
                                     events_start=ExpressiveConfiguration.
                                        bits_to_str(switch_dict["start"]),
                                     events_stop=ExpressiveConfiguration.
                                        bits_to_str(switch_dict["stop"])))
            for switcher in ["stop", "start"]:
                for bit in switch_dict[switcher]:
                    bit.switch(True if switcher == "start" else False)

        self.events_handler.connect_callback(
            event_name, callback_switch_expressive_recipes)

    def trigger_bit(self, object_name):
        recipes_dict = {recipe.name: recipe for recipe in self.recipes_list}
        all_names = self.bits_dict.keys() + recipes_dict.keys()
        error_message = "The specified ExpressiveBit ({}) can not be found in "\
            "the configuration file".format(object_name)
        self.logger.assert_warning(object_name in all_names,
                                   error_message)
        if object_name in self.bits_dict.keys():  # object_name is a bit name
            bit = self.bits_dict[object_name]
            self.logger.info("Triggering bit: {}".format(bit.name))
            bit.switch(True)
        else:  # object_name is a recipe name
            self.trigger_bit(recipes_dict[object_name].bit_name)

    def get_bits(self):
        """ Get all ExpressiveBits' data
        """
        return self.bits_dict

    def disconnect_callbacks(self):
        self.events_handler.disconnect_all_callbacks()

    def get_states(self):
        """ Get the last triggered Recipes
        """
        # todo: we should have state machine implementation for this to really
        # make sense, but for now we just take the latest recipes
        return [recipe.name for recipe in self.current_recipes]



